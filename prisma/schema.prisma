// Prisma schema for PostgreSQL read replica
// Used for complex queries, pagination, search, and reporting

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================
// AUDIT LOG TABLES (Per-Entity)
// =============================================
// Audit tables are created per entity type using raw SQL migrations.
// Each entity has its own audit table: {entity_type}_audit_logs
//
// Example: invoice_audit_logs, user_audit_logs, order_audit_logs
//
// See src/lib/audit for the decoupled audit logging system.
// The PostgresWriter uses raw SQL to write to dynamic table names.
//
// To create an audit table for a new entity, run:
//
// CREATE TABLE invoice_audit_logs (
//   id UUID PRIMARY KEY,
//   entity_id VARCHAR(100) NOT NULL,
//   operation VARCHAR(20) NOT NULL,
//   user_id VARCHAR(100) NOT NULL,
//   timestamp TIMESTAMPTZ NOT NULL,
//   changes JSONB NOT NULL,
//   snapshot_before JSONB,
//   snapshot_after JSONB,
//   metadata JSONB,
//   created_at TIMESTAMPTZ DEFAULT NOW()
// );
// CREATE INDEX idx_invoice_audit_entity ON invoice_audit_logs(entity_id, timestamp DESC);
// CREATE INDEX idx_invoice_audit_user ON invoice_audit_logs(user_id, timestamp DESC);
// CREATE INDEX idx_invoice_audit_timestamp ON invoice_audit_logs(timestamp DESC);
// =============================================

// =============================================
// ADD YOUR MODELS BELOW
// =============================================
//
// When creating a new service, define your domain models here.
// Follow these patterns for consistency:
//
// 1. Use UUID for primary keys
// 2. Include version, active, createdAt, updatedAt fields
// 3. Audit history is stored in per-entity audit tables (see above)
// 4. Use snake_case for database column names with @map
// 5. Use camelCase for Prisma field names
//
// Example model pattern:
//
// model YourEntity {
//   id         String   @id @default(uuid()) @db.Uuid
//   name       String
//   email      String   @unique
//   status     String   // Consider using enums for status fields
//   metadata   Json?    // Flexible JSON storage for additional data
//   version    Int      @default(1)
//   active     Boolean  @default(true)
//   createdAt  DateTime @default(now()) @map("created_at")
//   updatedAt  DateTime @updatedAt @map("updated_at")
//
//   // Add relations as needed
//   // relatedItems RelatedItem[]
//
//   @@index([status])  // Add indexes for frequently queried fields
//   @@map("your_entities")
// }
//
// For more examples, see src/modules/_example-entity/README.md
// =============================================
